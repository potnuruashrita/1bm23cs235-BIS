import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

# Load image as grayscale (replace 'your_image.jpg' with your image file)
img = Image.open('your_image.jpg').convert('L')
img_np = np.array(img)

# Fitness function: Otsu's between-class variance for threshold t
def otsu_fitness(t, image):
    t = int(t[0])
    if t <= 0 or t >= 255:
        return 0
    hist, _ = np.histogram(image, bins=256, range=(0,256))
    total_pixels = image.size

    weight_bg = np.sum(hist[:t]) / total_pixels
    weight_fg = np.sum(hist[t:]) / total_pixels

    if weight_bg == 0 or weight_fg == 0:
        return 0

    mean_bg = np.sum(np.arange(t) * hist[:t]) / np.sum(hist[:t])
    mean_fg = np.sum(np.arange(t, 256) * hist[t:]) / np.sum(hist[t:])

    between_class_variance = weight_bg * weight_fg * (mean_bg - mean_fg) ** 2
    return between_class_variance

# PSO parameters
num_particles = 30
max_iter = 50
w = 0.7     # inertia weight
c1 = 1.5    # cognitive coefficient
c2 = 1.5    # social coefficient

# Initialize particles randomly (threshold values between 0 and 255)
particles = np.random.uniform(0, 255, (num_particles, 1))
velocities = np.zeros_like(particles)

# Initialize personal bests
pbest_pos = particles.copy()
pbest_scores = np.array([otsu_fitness(p, img_np) for p in particles])

# Initialize global best
gbest_idx = np.argmax(pbest_scores)
gbest_pos = pbest_pos[gbest_idx].copy()
gbest_score = pbest_scores[gbest_idx]

for iteration in range(max_iter):
    for i in range(num_particles):
        r1 = np.random.rand()
        r2 = np.random.rand()

        velocities[i] = (w * velocities[i] +
                         c1 * r1 * (pbest_pos[i] - particles[i]) +
                         c2 * r2 * (gbest_pos - particles[i]))

        particles[i] = particles[i] + velocities[i]
        particles[i] = np.clip(particles[i], 0, 255)

        fitness_val = otsu_fitness(particles[i], img_np)

        if fitness_val > pbest_scores[i]:
            pbest_scores[i] = fitness_val
            pbest_pos[i] = particles[i].copy()

    gbest_idx = np.argmax(pbest_scores)
    if pbest_scores[gbest_idx] > gbest_score:
        gbest_score = pbest_scores[gbest_idx]
        gbest_pos = pbest_pos[gbest_idx].copy()

    print(f"Iteration {iteration+1}/{max_iter}, Best Score: {gbest_score:.2f}, Best Threshold: {int(gbest_pos[0])}")

# Apply best threshold to binarize image
threshold = int(gbest_pos[0])
binary_img = (img_np > threshold) * 255

# Display original and thresholded images
plt.subplot(1, 2, 1)
plt.title("Original Image")
plt.imshow(img_np, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title(f"Thresholded Image (T={threshold})")
plt.imshow(binary_img, cmap='gray')
plt.axis('off')

plt.show()
